// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import { SP1VerifierGateway } from "@sp1-contracts/SP1VerifierGateway.sol";

contract PV4D {
    uint256 immutable voterCount;
    SP1VerifierGateway immutable verifierGateway;
    bytes32 immutable vkey;

    bytes32[] publicKeys;
    mapping(bytes32 => bool) unusedRegistrationIds;
    mapping(bytes32 => bool) nullifiers;
    mapping(uint256 => uint256) votes;

    // these are generated by admin as keccak(setup password)
    constructor(bytes32[] memory _pks, address _verifierGateway, bytes32 _vkey) {
        for (uint i = 0; i < _pks.length; i++) {
            setupPKs[_pks[i]] = true;
        }
        voterCount = _pks.length;
        verifierGateway = SP1VerifierGateway(_verifierGateway);
        vkey = _vkey;
    }

    // user generates pubkey by keccak(private key)
    function addPublicKey(string calldata _registrationPassword, bytes32 _pubkey) public {
        bytes32 registrationId = keccak256(abi.encodePacked(_registrationPassword));
        require(unusedRegistrationIds[registrationId], "invalid password");
        unusedRegistrationIds[registrationId] = false;

        publicKeys.push(_pubkey);
    }

    // nullifier is sha2(private key)
    function vote(bytes32 _nullifier, uint256 _vote, bytes calldata _proof) public {
        require(publicKeys.length == voterCount, "not all public keys added");
        require(!nullifiers[_nullifier], "nullifier already used");
        verifierGateway.verifyProof(vkey, abi.encode(publicKeys, _nullifier), _proof);
        votes[_vote]++;
        nullifiers[_nullifier] = true;
    }

    function tally(uint256 _voteOptions) external view returns (uint256[] memory) {
        uint256[] memory result = new uint256[](_voteOptions);
        for (uint i = 0; i < _voteOptions; i++) {
            result[i] = votes[i];
        }
        return result;
    }
}
